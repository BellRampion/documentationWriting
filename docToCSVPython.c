/* COPYRIGHT AND LICENSE
Copyright 2019 by Bailie Livingston.
This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/

/*
Program to take the list of methods, etc generated by FindMethodsPython and turn them into a comma-separated values file.
Format: location,className,methodName,methodArgs,decoratorName,decoratorArgs
If a method has multiple decorators attatched to it, there will be multiple lines for that method, one for each decorator.
Written July 2019 by Bailie Livingston.
*/


#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <stdlib.h>

//Global variables
FILE *inputfile;
FILE *outputfile;
int classIndentLevel = 0;

//Macros
#define FALSE 0
//More than 20 is overkill. Really. It is.
#define MAX_DECORATORS 20
#define MAXLENGTH 10000
#define SPACES_IN_TAB 4
#define TRUE 1

//Functions
int copySubStr(char src[], char dest[], int srcStart, int srcEnd, int maxLen);
int getIndentLevel(char src[], int numSpaces);
int indexOfStr(char mainStr[], char subStr[]);
int pairMarkers(int openIndex, char closingChar, char src[]);
void parseDeclPython(char declLine[], char declType[], char location[], char class[], int indentLevel, int printExtras);

//Argv[1] is the input file, argv[2] is the output file
int main(int argc, char *argv[]){
    char *decoratorSet[MAX_DECORATORS];
    char *result;
    char className[MAXLENGTH];
    char inputline[MAXLENGTH];
    char location[MAXLENGTH];
    char outputline[MAXLENGTH];
    char tempArray[MAXLENGTH];
    int endIndex = 0;
    int hasDecorator = FALSE; //Flag if next method is decorated
    int indentLevel = 0;
    int iter = 0;
    int numDecorators = 0;
    int startIndex = 0;
    int tempLength;

    location[0] = '\0';

    if (argc < 3)
    {
        printf("Usage: docToCSVPython inputfilename outputfilename\nThe outputfile will be appended to.\n");
        return 1;
    }

    //Open files
    inputfile = fopen(argv[1], "r");
    outputfile = fopen(argv[2], "a");
    if (inputfile == NULL)
    {
        fprintf(stderr, "ERROR: file %s not found. Exiting.\n", argv[1]);
        return -1;
    }
    //Shouldn't happen, but just in case
    if (outputfile == NULL)
    {
        fprintf(stderr, "ERROR: file %s not found. Exiting.\n", argv[2]);
        return -1;
    }

    //Copy input filepath to location array
    strcpy(location, argv[1]);

    //Parse fileline
    while (fgets(inputline, MAXLENGTH, inputfile) != NULL){

        //Get indentation level of line
        indentLevel = getIndentLevel(inputline, SPACES_IN_TAB);

        //Check to see if this line has a filename on it
        if ((result = strstr(inputline, "From ")) != NULL)
        {
            //Get rest of string
            result += strlen("From ");
            strncpy(location, result, MAXLENGTH);
            printf("Location: %s\n", location);
            //Remove the newline or return
            if (location[strlen(location) - 2] == '\r')
            {
                location[strlen(location) - 2] = '\0';
            }
            else if (location[strlen(location) - 1] == '\n')
            {
                location[strlen(location) - 1] = '\0';
            }
            else ;

            //Reset class name and indentation
            className[0] = '\0';
            classIndentLevel = 0;
        }

        //Check to see if this line has a class definition
        else if ((result = strstr(inputline, "class ")) != NULL)
        {
            //Get class name
            result += strlen("class ");
            startIndex = result - inputline;
            endIndex = indexOfStr(inputline, "(");

            //If there was a match, pull out the name
            if (endIndex != -1)
            {
                tempLength = copySubStr(inputline, tempArray, startIndex, endIndex - 1, MAXLENGTH - 1);
                //If there wasn't an error, continue
                if (tempLength > 0)
                {
                    //Make this class name the new main class name and indent level the new class indent level
                    strncpy(className, tempArray, MAXLENGTH);
                    classIndentLevel = indentLevel;
                }
            }
            //Not all classes have the parentheses
            else
            {
                //Print rest of line minus the newline and colon, plus a comma (name and param. columns)
                tempLength = copySubStr(inputline, tempArray, result - inputline, strlen(inputline) - 3, MAXLENGTH - 1);
                //Make this class name the new main class name and indent level the new class indent level
                strncpy(className, tempArray, MAXLENGTH);
                classIndentLevel = indentLevel;
            }
        }
        else if ((result = strchr(inputline, '@')) != NULL)
        {
            //Some lines may have more than one decorator. In that case, they need to be saved into a separate string
            if (hasDecorator == TRUE && numDecorators < MAX_DECORATORS)
            {
                //Allocates memory for the line. The sizeof(char) is redundant; it will always equal 1
                decoratorSet[numDecorators] = malloc(sizeof(char) * (strlen(inputline) + 1));
                //Copy in line and increase number by one
                strncpy(decoratorSet[numDecorators], inputline, strlen(inputline) + 1);
                numDecorators++;
            }
            else
            {
                numDecorators = 1;
                //Allocate memory
                decoratorSet[0] = malloc(strlen(inputline) + 1);
                if (decoratorSet[0] == NULL)
                {
                    fprintf(stderr, "Call to malloc failed. Memory not allocated correctly. Aborting.\n");
                    return -1;
                }
                //Save decorator line for later use
                strncpy(decoratorSet[0], inputline, strlen(inputline) + 1);
                hasDecorator = TRUE;
            }
        } //End checking decorations

        //Check if line is a method
        else if ((result = strstr(inputline, "def ")) != NULL)
        {
            //Parse fileline
            parseDeclPython(inputline, "def ", location, className, indentLevel, TRUE);

            if (hasDecorator == TRUE && numDecorators == 1)
            {
                parseDeclPython(decoratorSet[0], "", location, className, indentLevel, FALSE);
                //Print the newline
                fprintf(outputfile, "\n");
            }
            else if (hasDecorator == TRUE && numDecorators > 1)
            {
                //Print the first decorator, then start printing <method line> <decorator> until they're all finished
                parseDeclPython(decoratorSet[0], "", location, className, indentLevel, FALSE);
                fprintf(outputfile, "\n");
                free(decoratorSet[0]);
                for (int i = 1; i < numDecorators; i++){
                    parseDeclPython(inputline, "def ", location, className, indentLevel, TRUE);
                    //Leaving indent level the same works because the indent level of the decorator will always match the method's
                    parseDeclPython(decoratorSet[i], "", location, className, indentLevel, FALSE);
                    fprintf(outputfile, "\n");
                    free(decoratorSet[i]);
                }
            }
            else fprintf(outputfile, ",,\n");

            //Reset decorator flag and number
            hasDecorator = FALSE;
            numDecorators = 0;
        } //End checking def
        //No need to do anything with lines that don't match
        else ;

    }
    printf("Finished! Output is in %s.\n", argv[2]);

    fclose(inputfile);
    fclose(outputfile);

} //End of main()

//Finds and returns the index of the first char of subStr in mainStr, or -1 if not found
int indexOfStr(char *mainStr, char *subStr){
    int index;
    char *result;

    //If the substring is in the main string, find and return the index
    if ((result = strstr(mainStr, subStr)) != NULL)
    {
        index = result - mainStr;
        return index;
    }
    //If no match, return -1
    else return -1;

    //Shouldn't happen, but as a safety net
    return 0;
}

//Copies a substring from src to dest using subStart and subEnd as indexes. Copies at most maxLen chars, not including the NULL pointer
int copySubStr(char src[], char dest[], int srcStart, int srcEnd, int maxLen){
    int iter, i;

    //Make sure start is less than end
    if (srcStart > srcEnd)
        return -1;

    //Make sure end is less than maxLen
    if (srcEnd > maxLen)
        return -2;

    //If srcEnd is -1, go to the end of the array
    if (srcEnd == -1)
        srcEnd = strlen(src);

    //Copy substring bounded by srcStart and srcEnd to dest
    for (iter = srcStart, i = 0; iter <= srcEnd && src[iter] != '\0' && i < maxLen; iter++, i++){
        dest[i] = src[iter];
    }

    dest[i] = '\0';

    //Return length of dest
    return i;
}

//Returns the indent level of a string, calculated by the number of spaces or tabs before the first non-whitespace character
int getIndentLevel(char src[], int numSpaces){
    int indentLevel = 0;
    int i;
    int spaceCount = 0; //For keeping track of how many spaces have been found so far

    //loop through string and check for whitespace until first non-whitespace character found
    for (i = 0; i < MAXLENGTH && src[i] != '\0'; i++){
        if (src[i] == 32)
        {
            spaceCount++;
        }
        else if (src[i] == '\t')
        {
            indentLevel++;
        }
        else break;

        //Check if a new indent level has been reached; if so, reset count
        if (spaceCount == numSpaces)
        {
            indentLevel++;
            spaceCount = 0;
        }
    }

    return indentLevel;

} //End getIndentLevel

//Given an opening marker index and the closing marker char, finds the matching closing marker for the opening marker at the index in src
int pairMarkers(int openIndex, char closingChar, char src[]){

    /*This function works by counting the number of markers found so far. The counter starts at 0. When the program finds another opening marker, it increases the counter by 1. When it finds the next closing marker, it decreases the counter by 1. When the counter reaches zero again and the closing marker is found, it must be the corresponding closing marker for the given opening one.*/

    int i, counter;
    char openingChar;

    counter = 0;

    //Make sure that openIndex is actually within the bounds of src's length
    if (strlen(src) <= openIndex)
        return -2;

    //Look through src for the closing marker, starting at the given index
    i = openIndex;
    openingChar = src[i];
    while (src[i] != '\0'){
        if (src[i] == openingChar)
        {
            counter++;
        }
        else if (src[i] == closingChar)
        {
            counter--;
            if (counter == 0)
            {
                return i;
            }
        }
        else ;
        i++;
    }

    //-1 means closing char not found
    return -1;
}

//Parses a declaration line and separates the pieces into comma-separated values
void parseDeclPython(char declLine[], char declType[], char location[], char class[], int indentLevel, int printExtras){
    char *result;
    char tempArray[MAXLENGTH];
    int startIndex;
    int endIndex;
    int tempLength;

//NOTE: The newline will be printed by the caller

    if (printExtras == TRUE)
    {
        //Print location and class name to file
        fprintf(outputfile, "%s", location);
        if (indentLevel > classIndentLevel && class[0] != '\0')
        {
            fprintf(outputfile, ",%s,", class);
        }
        else
        {
            fprintf(outputfile, ",,");
            //Reset class indent level and classname
            class[0] = '\0';
            classIndentLevel = 0;
        }
    }
    else fprintf(outputfile, ",");

    result = declLine;
    //Skip whitespace
    for (int i = 0; i < MAXLENGTH -1 && result[i] != '\0' && isspace(*result); i++)
        result++;
    result += strlen(declType);
    startIndex = result - declLine;
    endIndex = indexOfStr(declLine, "(");

    //If there was a match, pull out the name
    if (endIndex != -1)
    {
        tempLength = copySubStr(declLine, tempArray, startIndex, endIndex - 1, MAXLENGTH - 1);
        //If there wasn't an error, continue
        if (tempLength > 0)
        {
            //Print name to file
            fprintf(outputfile, "%s", tempArray);

            // = Get parameters and print entire list between single quotes =

            startIndex = endIndex;
            endIndex = pairMarkers(startIndex, ')', declLine);

            //If there was a match for the endIndex and the start is smaller than the end,
            if (endIndex != -1 && endIndex != -2 && startIndex < endIndex)
            {
                //Pull out the parameters and write them to the file
                tempLength = copySubStr(declLine, tempArray, startIndex + 1, endIndex - 1, MAXLENGTH - 1);
                if (tempLength > 0)
                {
                    fprintf(outputfile, ",\"%s\"", tempArray);
                }
                else fprintf(outputfile, ",");
            }
            else fprintf(outputfile, ",");
        }
        //Print the commas that would have been there
        else
        {
            printf("Error code: %i\n", tempLength);
            fprintf(outputfile, ",,");
        }
    }
    else
    {
        //Print rest of line minus the newline, plus a comma (name and param. columns)
        tempLength = copySubStr(declLine, tempArray, result - declLine, strlen(declLine) - 2, MAXLENGTH - 1);
        fprintf(outputfile, "%s,", tempArray);
    }

    return;

}
